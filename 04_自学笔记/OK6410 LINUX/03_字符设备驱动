驱动程序: 使硬件工作的程序

Linux驱动程序主要是为了解决 软件的复用、接口统一

Liunx下驱动分类(之一)
字符设备驱动:以字节为最小访问单位
网络接口驱动:发送和接受报文
块设备驱动: 一次传送一个或多个块(512字节)的设备，当然Liunx无次限制

Linux驱动安装
1.模块安装
2.直接编译进内核
	1.kconfig
	2.Makefile
	如果在Liunx源码下的drivers下的char文件夹里面加一个hello.c

	在kconfig里面添加:     （为了在menuconfig命令后出现的配置界面中出现相应的选项） 
	config HELLO
		bool "hello driver" #bool表示两种选项，"hello driver"为enuconfig命令后出现的配置界面中名字
	
	在Makefile中追加
	obj-$(CONFIG_HELLO)    += hello.o #CONFIG_HELLO 由kconfig中的 config HELLO决定


Linux用户程序通过设备文件（设备节点）来使用驱动程序。
设备节点在/dev目录下面



设备号：
在/dev目录下执行ls -l就会出现
......
crw--w----  1 root tty       4,   0 5月  24 22:45 tty0
......
开头的c表示使字符设备 4表示主设备号 0表示次设备号
每一个字符设备文件对应一个主设备号，每一个字符设备驱动对应一个主设备号。所有主设备号的作用是连接设备文件和设备驱动
主设备号反应设备类型
次设备号用来变别那个设备

设备号在内核中使用dev_t实质unsigned int 32整数来定义，其中高12位为主设备号，低20为为次设备号。MAJOR(dev_t dev)获取主设备号 MINOR(dev_t dev)获取次设备号

Linux的设备号的申请
静态申请: 
	1.根据Linux源码中Documentation/devices.txt 确定一个没有使用的主设备号
	2.使用register_chrdev_region()函数注册设备号
函数:int register_chrdev_region(dev_t from,unsigned count const char *name)
功能:申请使用从from开始的count个设备号(主设备号不变，次设备号增加)
参数:from 希望申请使用的设备号，count设备号数目，name设备名(体现在/proc/devices)

动态申请:
	使用alloc_chrdev_region分配设备号，但是无法在驱动安装前创建设备文件
函数: int alloc_chrdev_region(dev_t *dev,unsigned baseminor,unsigned count const char *name)
功能:请求内核动态分配count个设备号，且次设备号从baseminor开始
参数:dev 分配到的设备号，baseminor起始次设备号，count设备号数目，name设备名


Linux的设备号的释放


